#!/usr/bin/env python3
"""
Doorbell System
===============

Simple doorbell system that monitors for your configured RF button
and sends Telegram notifications when pressed.

Usage:
1. Run button discovery tool first: python3 src/button_discovery_tool.py
2. Set Telegram credentials in .env file
3. Run this: python3 src/doorbell.py
"""

# Standard library imports
import time
import json
import os
import signal
import sys
import requests

# Third-party imports for RF signal detection and environment variables
from rpi_rf import RFDevice
from dotenv import load_dotenv

# Get the directory where this script is located and the project root
script_dir = os.path.dirname(os.path.abspath(__file__))
project_dir = os.path.dirname(script_dir)

# Load environment variables from .env file
env_file = os.path.join(project_dir, '.env')
load_dotenv(env_file)

# GPIO pin configuration (default to GPIO 27)
GPIO_PIN = int(os.getenv('GPIO_DATA_PIN', '27'))

# Configuration from environment variables
BOT_TOKEN = os.getenv('BOT_TOKEN')
CHAT_ID = os.getenv('CHAT_ID')

if not BOT_TOKEN:
    raise ValueError("BOT_TOKEN must be set in .env file")
if not CHAT_ID:
    raise ValueError("CHAT_ID must be set in .env file")

# Load button code from configuration file (generated by discovery tool)
config_file = os.path.join(project_dir, 'button_config.json')
with open(config_file, 'r') as f:
    BUTTON_CODE = json.load(f)['BUTTON_CODE']

print(f"üîî Doorbell System - Monitoring button code {BUTTON_CODE}")
print("Press Ctrl+C to exit.")

# Initialize RF device
rfdevice = None

def cleanup():
    """Clean up GPIO resources - releases GPIO pins so they can be used again"""
    global rfdevice
    if rfdevice:
        rfdevice.cleanup()
    print("Doorbell stopped.")

def signal_handler(signum, frame):
    """Handle SIGTERM (sent by systemd) - ensures cleanup runs before exit"""
    cleanup()
    sys.exit(0)

# Register signal handler so cleanup runs when systemd stops the service
signal.signal(signal.SIGTERM, signal_handler)

def send_notification():
    """Send doorbell notification to Telegram."""
    try:
        message = f"üîî DOORBELL PRESSED! üîî\nTime: {time.strftime('%H:%M:%S')}"
        url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
        response = requests.post(url, data={"chat_id": CHAT_ID, "text": message}, timeout=5)
        response.raise_for_status()  # Raise exception if HTTP error
        print(f"‚úÖ Notification sent!")
    except Exception as e:
        print(f"‚ö†Ô∏è Warning: Failed to send notification: {e}")
        # Don't crash - just log the error and continue running

try:
    # Initialize RF device
    rfdevice = RFDevice(GPIO_PIN)
    rfdevice.enable_rx()
    
    # Debouncing variables to prevent multiple notifications
    last_notification_time = 0
    DEBOUNCE_TIME = 2.0  # Minimum seconds between notifications
    
    timestamp = None
    
    # Main detection loop
    while True:
        # Check if a new RF code was received
        if rfdevice.rx_code_timestamp != timestamp:
            timestamp = rfdevice.rx_code_timestamp
            code = rfdevice.rx_code
            
            # Only send notification for our configured button code
            if code == BUTTON_CODE:
                # Check if enough time has passed since last notification (debouncing)
                now = time.time()
                if (now - last_notification_time) >= DEBOUNCE_TIME:
                    send_notification()
                    last_notification_time = now
        
        time.sleep(0.01)

except KeyboardInterrupt:
    # Ctrl+C pressed - cleanup GPIO before exiting
    cleanup()
except Exception as e:
    # Error occurred - cleanup GPIO to prevent pins from getting stuck
    print(f"\n‚ùå Error: {e}")
    import traceback
    traceback.print_exc()  # Print full traceback for debugging
    if "GPIO busy" in str(e):
        print("üí° Tip: GPIO is still busy. Try running: sudo python3 cleanup-gpio.py")
    cleanup()
    sys.exit(1)
