#!/usr/bin/env python3
"""
Doorbell System
===============

Simple doorbell system that monitors for your configured RF button
and sends Telegram notifications when pressed.

Usage:
1. Run button discovery tool first: python3 scripts/button_discovery_tool.py
2. Set Telegram credentials in .env file
3. Run this: python3 scripts/doorbell.py
"""

# Standard library imports
import time
import json
import os
import requests

# Third-party imports for Raspberry Pi GPIO and environment variables
import RPi.GPIO as GPIO  # Controls GPIO pins on Raspberry Pi
from dotenv import load_dotenv  # Loads configuration from .env file

# Get the directory where this script is located
script_dir = os.path.dirname(os.path.abspath(__file__))
project_dir = os.path.dirname(script_dir)

# Load environment variables from .env file
env_file = os.path.join(project_dir, '.env')
load_dotenv(env_file)

# These values control how sensitive our RF detection is
DATA_PIN = int(os.getenv('GPIO_DATA_PIN', '5'))  # Which GPIO pin the RF receiver is connected to
MIN_PULSES = int(os.getenv('MIN_PULSES', '10'))  # Minimum pulses to consider a valid signal (filters noise)
GAP_THRESHOLD = float(os.getenv('GAP_THRESHOLD', '0.01'))  # Time gap (10ms) that indicates end of transmission

# Configuration from environment variables (configured in .env file)
BOT_TOKEN = os.getenv('BOT_TOKEN')  # Telegram bot token for sending notifications
CHAT_ID = os.getenv('CHAT_ID')  # Telegram chat ID to send notifications to

# Load button code from configuration file (generated by discovery tool)
config_file = os.path.join(project_dir, 'button_config.json')

with open(config_file, 'r') as f:
    BUTTON_CODE = json.load(f)['BUTTON_CODE']

print(f"ðŸ”” Doorbell System - Monitoring button {BUTTON_CODE}")
print("Press Ctrl+C to exit.")

# GPIO Setup - Configure the Raspberry Pi to read digital signals
GPIO.setmode(GPIO.BCM)  # Use Broadcom chip pin numbering (GPIO channel numbers)
GPIO.setup(DATA_PIN, GPIO.IN)  # Configure pin as INPUT to read RF receiver signals

# State tracking variables for pulse detection
last_state = GPIO.input(DATA_PIN)  # Previous HIGH/LOW state to detect changes
last_time = time.time()  # Timestamp of last state change
pulse_times = []  # List to store (state, duration) pairs for current transmission

# Debouncing variables to prevent multiple notifications
last_notification_time = 0  # Timestamp of last notification sent
DEBOUNCE_TIME = 2.0  # Minimum seconds between notifications (2 seconds)

def send_notification():
    """
    Send doorbell notification to Telegram.
    
    Creates a formatted message with timestamp and sends it via Telegram API.
    This is called when the configured button code is detected.
    """
    message = f"ðŸ”” DOORBELL PRESSED! ðŸ””\nTime: {time.strftime('%H:%M:%S')}"
    url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
    requests.post(url, data={"chat_id": CHAT_ID, "text": message})
    print(f"âœ… Notification sent!")

try:
    # Main detection loop - continuously poll GPIO pin for signal changes
    while True:
        # Read current state of GPIO pin (HIGH=1 or LOW=0)
        state = GPIO.input(DATA_PIN)
        now = time.time()
        
        # Detect state changes (HIGH->LOW or LOW->HIGH) to capture pulse timing
        if state != last_state:
            # Calculate how long the previous state lasted and store it
            pulse_times.append((last_state, now - last_time))
            # Update tracking variables for next iteration
            last_state = state
            last_time = now

        # Detect end of transmission using gap threshold
        # If no state change for GAP_THRESHOLD seconds, transmission is complete
        if pulse_times and (now - last_time) > GAP_THRESHOLD:
            # Only process if we have enough pulses (filters out noise)
            if len(pulse_times) >= MIN_PULSES:
                # Count HIGH pulses to generate button code (same logic as discovery tool)
                code = len([p for p in pulse_times if p[0] == 1])
                # Only send notification for our configured button (prevents spam)
                if code == BUTTON_CODE:
                    # Check if enough time has passed since last notification (debouncing)
                    if (now - last_notification_time) >= DEBOUNCE_TIME:
                        send_notification()
                        last_notification_time = now  # Update last notification time
                    else:
                        pass  # Silently ignore duplicate detections
            # Reset for next transmission
            pulse_times = []

        # Fast polling for responsive detection (0.1ms delay)
        time.sleep(0.0001)

except KeyboardInterrupt:
    # Graceful shutdown when user presses Ctrl+C
    GPIO.cleanup()  # CRITICAL: Always cleanup GPIO resources to prevent hardware conflicts
    print("Doorbell stopped.")