#!/usr/bin/env python3
"""
Doorbell System
===============

Simple doorbell system that monitors for your configured RF button
and sends Telegram notifications when pressed.

Usage:
1. Run button discovery tool first: python3 src/button_discovery_tool.py
2. Set Telegram credentials in .env file
3. Run this: python3 src/doorbell.py
"""

# Standard library imports
import time
import json
import os
import signal
import sys
import requests

# Third-party imports for RF signal detection and environment variables
import RPi.GPIO as GPIO
from rpi_rf import RFDevice
from dotenv import load_dotenv

# Local imports
from telegram_notifier import TelegramNotifier

# Get the directory where this script is located and the project root
script_dir = os.path.dirname(os.path.abspath(__file__))
project_dir = os.path.dirname(script_dir)

# Load environment variables from .env file
env_file = os.path.join(project_dir, '.env')
load_dotenv(env_file)

# GPIO pin configuration (default to GPIO 27)
GPIO_PIN = int(os.getenv('GPIO_DATA_PIN', '27'))

# Configuration from environment variables
BOT_TOKEN = os.getenv('BOT_TOKEN')
CHAT_ID = os.getenv('CHAT_ID')

if not BOT_TOKEN:
    raise ValueError("BOT_TOKEN must be set in .env file")
if not CHAT_ID:
    raise ValueError("CHAT_ID must be set in .env file")

# Load button code from configuration file (generated by discovery tool)
config_file = os.path.join(project_dir, 'button_config.json')
with open(config_file, 'r') as f:
    BUTTON_CODE = json.load(f)['BUTTON_CODE']

print(f"üîî Doorbell System - Monitoring button code {BUTTON_CODE}")
print("Press Ctrl+C to exit.")

# Initialize Telegram notifier
notifier = TelegramNotifier(BOT_TOKEN, CHAT_ID)

# Initialize RF device
rfdevice = None

def cleanup():
    """Clean up GPIO resources - releases GPIO pins so they can be used again"""
    global rfdevice
    if rfdevice:
        rfdevice.cleanup()
    print("Doorbell stopped.")

def signal_handler(signum, frame):
    """Handle SIGTERM (sent by systemd) - ensures cleanup runs before exit"""
    cleanup()
    sys.exit(0)

# Register signal handler so cleanup runs when systemd stops the service
signal.signal(signal.SIGTERM, signal_handler)

try:
    # Initialize RF device
    # RFDevice handles GPIO setup internally
    rfdevice = RFDevice(GPIO_PIN)
    rfdevice.enable_rx()
    
    # Debouncing variables to prevent multiple notifications
    last_notification_time = 0
    DEBOUNCE_TIME = 2.0  # Minimum seconds between notifications
    
    timestamp = None
    
    # Main detection loop
    while True:
        # Check if a new RF code was received
        if rfdevice.rx_code_timestamp != timestamp:
            timestamp = rfdevice.rx_code_timestamp
            code = rfdevice.rx_code
            
            # Only send notification for our configured button code
            if code == BUTTON_CODE:
                # Check if enough time has passed since last notification (debouncing)
                now = time.time()
                if (now - last_notification_time) >= DEBOUNCE_TIME:
                    notifier.notify_doorbell()
                    last_notification_time = now
        
        time.sleep(0.01)

except KeyboardInterrupt:
    # Ctrl+C pressed - cleanup GPIO before exiting
    cleanup()
except Exception as e:
    # Error occurred - cleanup GPIO to prevent pins from getting stuck
    print(f"\n‚ùå Error: {e}")
    import traceback
    traceback.print_exc()  # Print full traceback for debugging
    if "GPIO busy" in str(e) or "edge detection" in str(e):
        print("üí° Tip: GPIO is still busy or edge detection failed. Try running: sudo python3 cleanup-gpio.py")
    cleanup()
    sys.exit(1)
