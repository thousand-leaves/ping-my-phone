#!/usr/bin/env python3
"""
B2: Dynamic Button Configuration - Targeted Notifications
========================================================

This version solves the spam problem from B1 by using dynamic button configuration.
Instead of sending notifications for ALL RF signals, it only sends notifications
for a specific button code that can be configured.

SUCCESS ACHIEVED:
- Eliminated notification spam by filtering signals
- Uses button discovery tool to identify the correct button code
- Only sends notifications for the configured button
- Makes the system practical for daily use

DECISION MADE:
- Implemented dynamic button configuration system
- Created button discovery tool to identify specific button codes
- Added filtering to prevent notification spam
"""

# Standard library imports
import time
import json
import os
import requests

# Third-party imports for Raspberry Pi GPIO and environment variables
import RPi.GPIO as GPIO  # Controls GPIO pins on Raspberry Pi
from dotenv import load_dotenv  # Loads configuration from .env file

# Load environment variables from .env file
load_dotenv()

# Configuration from environment variables (configured in .env file)
# These values control how sensitive our RF detection is
DATA_PIN = int(os.getenv('GPIO_DATA_PIN', '5'))  # Which GPIO pin the RF receiver is connected to
MIN_PULSES = int(os.getenv('MIN_PULSES', '10'))  # Minimum pulses to consider a valid signal (filters noise)
GAP_THRESHOLD = float(os.getenv('GAP_THRESHOLD', '0.01'))  # Time gap (10ms) that indicates end of transmission
BOT_TOKEN = os.getenv('BOT_TOKEN')  # Telegram bot token for sending notifications
CHAT_ID = os.getenv('CHAT_ID')  # Telegram chat ID to send notifications to

# Load button code from configuration file (generated by discovery tool)
with open('button_config.json', 'r') as f:
    BUTTON_CODE = json.load(f)['BUTTON_CODE']

print(f"ðŸ”” Doorbell System - Monitoring button {BUTTON_CODE}")
print("Press Ctrl+C to exit.")

# GPIO Setup - Configure the Raspberry Pi to read digital signals
GPIO.setmode(GPIO.BCM)  # Use Broadcom chip pin numbering (GPIO channel numbers)
GPIO.setup(DATA_PIN, GPIO.IN)  # Configure pin as INPUT to read RF receiver signals

# State tracking variables for pulse detection
last_state = GPIO.input(DATA_PIN)  # Previous HIGH/LOW state to detect changes
last_time = time.time()  # Timestamp of last state change
pulse_times = []  # List to store (state, duration) pairs for current transmission

def send_notification():
    """
    Send doorbell notification to Telegram.
    
    Creates a formatted message with timestamp and sends it via Telegram API.
    This is called when the configured button code is detected.
    """
    message = f"ðŸ”” DOORBELL PRESSED! ðŸ””\nTime: {time.strftime('%H:%M:%S')}"
    url = f"https://api.telegram.org/bot{BOT_TOKEN}/sendMessage"
    requests.post(url, data={"chat_id": CHAT_ID, "text": message})
    print(f"âœ… Notification sent!")

try:
    # Main detection loop - continuously poll GPIO pin for signal changes
    while True:
        # Read current state of GPIO pin (HIGH=1 or LOW=0)
        state = GPIO.input(DATA_PIN)
        now = time.time()
        
        # Detect state changes (HIGH->LOW or LOW->HIGH) to capture pulse timing
        if state != last_state:
            # Calculate how long the previous state lasted and store it
            pulse_times.append((last_state, now - last_time))
            # Update tracking variables for next iteration
            last_state = state
            last_time = now

        # Detect end of transmission using gap threshold
        # If no state change for GAP_THRESHOLD seconds, transmission is complete
        if pulse_times and (now - last_time) > GAP_THRESHOLD:
            # Only process if we have enough pulses (filters out noise)
            if len(pulse_times) >= MIN_PULSES:
                # Count HIGH pulses to generate button code (same logic as discovery tool)
                code = len([p for p in pulse_times if p[0] == 1])
                # Only send notification for our configured button (prevents spam)
                if code == BUTTON_CODE:
                    send_notification()
            # Reset for next transmission
            pulse_times = []

        # Fast polling for responsive detection (0.1ms delay)
        time.sleep(0.0001)

except KeyboardInterrupt:
    # Graceful shutdown when user presses Ctrl+C
    GPIO.cleanup()  # CRITICAL: Always cleanup GPIO resources to prevent hardware conflicts
    print("Doorbell stopped.")